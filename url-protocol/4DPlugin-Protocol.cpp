/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Protocol.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Protocol
 #	author : miyako
 #	2022/04/20
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Protocol.h"

#define CALLBACK_IN_NEW_PROCESS 0
#define CALLBACK_SLEEP_TIME 59

std::mutex globalMutex; /* for INSERT_RECORDS,UPDATE_RECORDS,DELETE_RECORDS */
std::mutex globalMutex1;/* for METHOD_PROCESS_ID */
std::mutex globalMutex2;/* for LISTENER_METHOD */
std::mutex globalMutex3;/* PROCESS_SHOULD_TERMINATE */
std::mutex globalMutex4;/* PROCESS_SHOULD_RESUME */

#pragma mark -

typedef std::basic_string<PA_Unichar> CUTF16String;

namespace customurl
{
    //constants
    process_name_t MONITOR_PROCESS_NAME = (PA_Unichar *)"$\0C\0U\0S\0T\0O\0M\0 \0U\0R\0L\0\0\0";
    process_stack_size_t MONITOR_PROCESS_STACK_SIZE = 0;
    
    //context management
    std::vector<CUTF16String> CUSTOM_URL;
    
    CUTF16String LISTENER_METHOD;

    //callback management
    process_number_t METHOD_PROCESS_ID = 0;
    bool PROCESS_SHOULD_TERMINATE = false;
    bool PROCESS_SHOULD_RESUME = false;

#if VERSIONWIN
    UINT messageIdentifier = 0;
    HWND hwnd = NULL;
	const wchar_t* messageWindowClass = L"PROTOCOL_MESSAGE_WINDOW";
#endif
}

#pragma mark -

#define MAX_PROCESS_NAME 256

bool IsProcessOnExit()
{
    std::vector<PA_Unichar> name(MAX_PROCESS_NAME);

    PA_long32 state, time;
    
    PA_GetProcessInfo(PA_GetCurrentProcessNumber(), (PA_Unichar *)&name[0], &state, &time);
    
    CUTF16String procName((PA_Unichar *)&name[0]);
    CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
    return (!procName.compare(exitProcName));
}

#if VERSIONMAC
static void Callback(CFNotificationCenterRef center,
                     void *observer,
                     CFStringRef name,
                     const void *object,
                     CFDictionaryRef userInfo);
#endif

#if VERSIONWIN
LRESULT CALLBACK Callback(
                          HWND hwnd,
                          UINT uMsg,
                          WPARAM wParam,
                          LPARAM lParam);
#endif

void listener_start()
{
#if VERSIONMAC
    CFNotificationCenterRef distributedCenter = CFNotificationCenterGetDistributedCenter();
    CFNotificationSuspensionBehavior behavior = CFNotificationSuspensionBehaviorDeliverImmediately;
    CFNotificationCenterAddObserver(distributedCenter,
                                    NULL,
                                    Callback,
                                    CFSTR("com.4D.Protocol"),
                                    NULL,
                                    behavior);
#endif
#if VERSIONWIN
    customurl::messageIdentifier = RegisterWindowMessage(L"com.4D.Protocol");
    
    if(customurl::messageIdentifier) {

		WNDCLASSEX wx = {};
		wx.cbSize = sizeof(WNDCLASSEX);
		wx.style = CS_HREDRAW | CS_VREDRAW;
		wx.lpfnWndProc = Callback;       
		wx.hInstance = (HINSTANCE)PA_Get4DHInstance();
		wx.lpszClassName = customurl::messageWindowClass;

		ATOM atom = RegisterClassEx(&wx);

		customurl::hwnd = CreateWindowEx(0,
			customurl::messageWindowClass,
			customurl::messageWindowClass,
			0,
			CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
			HWND_MESSAGE /* parent */,
			NULL /* menu */,
			(HINSTANCE)PA_Get4DHInstance(),
			NULL);

		if (customurl::hwnd) {
			ChangeWindowMessageFilterEx(customurl::hwnd, customurl::messageIdentifier, MSGFLT_ALLOW, NULL);
		}
    }
#endif
}

void OnStartup()
{
    PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listener_start, NULL);

    listenerLoopStart();
}

void OnCloseProcess()
{
    if(IsProcessOnExit())
    {
        listenerLoopFinish();
    }
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
                
#if VERSIONMAC
            case kCloseProcess :
                OnCloseProcess();
                break;
#endif

#if VERSIONWIN
            case kDeinitPlugin :
            case kServerDeinitPlugin :
                if(customurl::hwnd) {
                    CloseWindow(customurl::hwnd);
                }
                break;
#endif

			// --- Protocol
            
			case 1 :
				REGISTER_PROTOCOL(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#if VERSIONMAC
static void registerApp() {
    
    NSBundle *thisBundle = [NSBundle bundleWithIdentifier:@"com.4D.Protocol"];
    if(thisBundle) {
        NSURL *url = [[thisBundle executableURL]URLByAppendingPathComponent:@"url-redirect.app"];
        if(url) {
            OSStatus status = LSRegisterURL((CFURLRef)url, false);
        }
    }
}
#endif

#if VERSIONWIN
static void registerApp(std::wstring& scheme) {
    
    wchar_t    thisPath[_MAX_PATH] = {0};
    wchar_t    fDrive[_MAX_DRIVE], fDir[_MAX_DIR], fName[_MAX_FNAME], fExt[_MAX_EXT];
    
    HMODULE hplugin = GetModuleHandleW(L"Protocol.4DX");
    GetModuleFileNameW(hplugin, thisPath, _MAX_PATH);
    _wsplitpath_s(thisPath, fDrive, fDir, fName, fExt);
    
    std::wstring path = fDrive;
    path += fDir;//path to plugin parent folder
    
    if(path.at(path.size() - 1) != L'\\')//remove delimiter
        path += L'\\';
    
    path += L"url-redirect.exe";
    
    HKEY hkprotocol = NULL;
    HKEY hkcommand = NULL;
    DWORD dwDisposition;
    
	LONG err = RegCreateKeyEx(HKEY_CURRENT_USER,
		scheme.c_str(),
		0,
		NULL,
		REG_OPTION_NON_VOLATILE,
		KEY_READ | KEY_WRITE | KEY_CREATE_SUB_KEY | KEY_SET_VALUE,
		NULL,
		&hkprotocol,
		&dwDisposition);
    
    if(hkprotocol != 0) {
         
        std::wstring URL_PROTOCOL = L"URL Protocol";
                    
		err = RegSetValueEx(hkprotocol,
			URL_PROTOCOL.c_str(),
			0,
			REG_SZ,
			NULL,
			0);

		err = RegCreateKeyEx(hkprotocol,
			L"shell\\open\\command",
			0,
			NULL,
			REG_OPTION_NON_VOLATILE,
			KEY_READ | KEY_WRITE | KEY_CREATE_SUB_KEY | KEY_SET_VALUE,
			NULL,
			&hkcommand,
			&dwDisposition);
        
        if(hkcommand != 0) {
            
			path = L"\"" + path;
			path += L"\" \"%1\"";
            
            err = RegSetValueEx(hkcommand,
                                NULL,
                                0,
                                REG_SZ,
                                (LPBYTE)path.c_str(),
				path.length()*sizeof(wchar_t));
            
            RegCloseKey(hkcommand);
        }
        
        RegCloseKey(hkprotocol);
        
        wchar_t* ProtocolExecute = L"Software\\Microsoft\\Internet Explorer\\ProtocolExecute";

        HKEY hkcu = NULL;
        
		LONG err = RegOpenKeyEx(HKEY_CURRENT_USER,
			ProtocolExecute,
			REG_OPTION_NON_VOLATILE,
			KEY_READ | KEY_WRITE | KEY_CREATE_SUB_KEY | KEY_SET_VALUE,
			&hkcu);

        if(hkcu != 0) {
            
            hkprotocol = NULL;
            
			err = RegCreateKeyEx(
				hkcu,
				scheme.c_str(),
				0,
				NULL,
				REG_OPTION_NON_VOLATILE,
				KEY_READ | KEY_WRITE | KEY_CREATE_SUB_KEY | KEY_SET_VALUE,
				NULL,
				&hkprotocol,
				&dwDisposition);
            
            if(hkprotocol != 0) {
                
				DWORD noValue = 0;
				err = RegSetValueEx(hkprotocol,
					L"WarnOnOpen",
					0,
					REG_DWORD,
					(LPBYTE)&noValue,
					sizeof(DWORD));
                
                RegCloseKey(hkprotocol);
            }
            
            RegCloseKey(hkcu);
        }
    
        auto func = [](UINT timeout) {
        /*
		SendMessageTimeout(
				HWND_BROADCAST,
				WM_SETTINGCHANGE,
				0,
				(LPARAM)L"WarnOnOpen",
				SMTO_ABORTIFHUNG,
				timeout,
				NULL);
		*/
			PostMessage(
				HWND_BROADCAST,
				WM_SETTINGCHANGE,
				0,
				(LPARAM)L"WarnOnOpen");
			
        };
        
        std::async(std::launch::async, func, 1000);

    }
}
#endif

#pragma mark -

void REGISTER_PROTOCOL(PA_PluginParameters params) {

    PA_Unistring arg0 = PA_GetApplicationFullPath();
    PA_Unistring *arg1 = PA_GetStringParameter(params, 1);
    PA_Unistring *arg2 = PA_GetStringParameter(params, 2);
        
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        if(arg2->fLength) {
            customurl::LISTENER_METHOD = arg2->fString;
        }else{
            customurl::LISTENER_METHOD = (PA_Unichar *)"\0\0";
        }
 
    }
    
#if VERSIONMAC
    
    registerApp();
    
    CFStringRef scheme = CFStringCreateWithCharacters(kCFAllocatorDefault,
                                                      (const UniChar *)arg1->fString, arg1->fLength);

    if(scheme) {

        OSStatus err = LSSetDefaultHandlerForURLScheme(scheme, CFSTR("com.4D.url-redirect"));
        
        if(!err){
            NSLog(@"registered url scheme:%@", scheme);
        }else
        {
            NSLog(@"failed registered url scheme:%@, error %d", scheme, (int)err);
        }
        
//        CFStringRef defaultHandler = LSCopyDefaultHandlerForURLScheme(scheme);
//        NSLog(@"current default handler:%@", defaultHandler);
//        CFRelease(defaultHandler);
        
        CFRelease(scheme);
    }

#endif
    
#if VERSIONWIN
    
    std::wstring scheme((wchar_t *)arg1->fString, arg1->fLength);
    
    if(scheme.length()) {
        registerApp(scheme);
    }
    
#endif
}

#pragma mark -

static void generateUuid(CUTF16String &uuid) {
    
#if VERSIONWIN
    RPC_WSTR str;
    UUID uid;
    if (UuidCreate(&uid) == RPC_S_OK) {
        if (UuidToString(&uid, &str) == RPC_S_OK) {
            size_t len = wcslen((const wchar_t *)str);
            std::vector<wchar_t>buf(len+1);
            memcpy(&buf[0], str, len * sizeof(wchar_t));
            _wcsupr((wchar_t *)&buf[0]);
            uuid = CUTF16String((const PA_Unichar *)&buf[0], len);
            RpcStringFree(&str);
        }
    }
#else
    NSString *u = [[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""];
    uint32_t len = [u length];
    uint32_t size = (len * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
    std::vector<uint8_t> buf(size);
    
    if([u getCString:(char *)&buf[0] maxLength:size encoding:NSUnicodeStringEncoding]){
        uuid = CUTF16String((const PA_Unichar *)&buf[0], len);
    }else{
        uuid = (PA_Unichar *)"\0\0";
    }
#endif
}

#pragma mark -

void listener_end()
{
#if VERSIONMAC
    /* do this in main process */
    CFNotificationCenterRef distributedCenter = CFNotificationCenterGetDistributedCenter();
    CFNotificationCenterRemoveObserver(distributedCenter, NULL, CFSTR("com.4D.Protocol"), NULL);
#endif

#if VERSIONWIN
		if (customurl::hwnd) {
			CloseWindow(customurl::hwnd);
			customurl::hwnd = NULL;
		}
		UnregisterClass(customurl::messageWindowClass, NULL);
#endif
}

void listenerLoop()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        customurl::PROCESS_SHOULD_TERMINATE = false;
    }
    
    /* Current process returns 0 for PA_NewProcess */
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    
    while(!PA_IsProcessDying())
    {
        PA_YieldAbsolute();
        
        bool PROCESS_SHOULD_RESUME;
        bool PROCESS_SHOULD_TERMINATE;
        
        if(1)
        {
            PROCESS_SHOULD_RESUME = customurl::PROCESS_SHOULD_RESUME;
            PROCESS_SHOULD_TERMINATE = customurl::PROCESS_SHOULD_TERMINATE;
        }
        
        if(PROCESS_SHOULD_RESUME)
        {
            size_t URLs;
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex);
                
                URLs = customurl::CUSTOM_URL.size();
            }
            
            while(URLs)
            {
                PA_YieldAbsolute();
                
                if(CALLBACK_IN_NEW_PROCESS)
                {
                    CUTF16String processName;
                    generateUuid(processName);
                    PA_NewProcess((void *)listenerLoopExecuteMethod,
                                  customurl::MONITOR_PROCESS_STACK_SIZE,
                                  (PA_Unichar *)processName.c_str());
                }else
                {
                     listenerLoopExecuteMethod();
                }
                
                if(PROCESS_SHOULD_TERMINATE)
                    break;
                
                if(1)
                {
                    std::lock_guard<std::mutex> lock(globalMutex);
                    
                    URLs = customurl::CUSTOM_URL.size();
                    PROCESS_SHOULD_TERMINATE = customurl::PROCESS_SHOULD_TERMINATE;
                }
            }
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex4);
                
                customurl::PROCESS_SHOULD_RESUME = false;
            }
            
        }else
        {
            PA_PutProcessToSleep(currentProcessNumber, CALLBACK_SLEEP_TIME);
        }
        
        if(1)
        {
            PROCESS_SHOULD_TERMINATE = customurl::PROCESS_SHOULD_TERMINATE;
        }
        
        if(PROCESS_SHOULD_TERMINATE)
            break;
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        customurl::CUSTOM_URL.clear();
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        customurl::LISTENER_METHOD = (PA_Unichar *)"\0\0";
    }

    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        customurl::METHOD_PROCESS_ID = 0;
    }
    
    PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listener_end, NULL);
    
    PA_KillProcess();
}

void listenerLoopStart()
{
    if(!customurl::METHOD_PROCESS_ID)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        customurl::METHOD_PROCESS_ID = PA_NewProcess((void *)listenerLoop,
                                                     customurl::MONITOR_PROCESS_STACK_SIZE,
                                                     customurl::MONITOR_PROCESS_NAME);
    }
}

void listenerLoopFinish()
{
    if(customurl::METHOD_PROCESS_ID)
    {
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex3);
            
            customurl::PROCESS_SHOULD_TERMINATE = true;
        }
        
        PA_YieldAbsolute();
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex4);

            customurl::PROCESS_SHOULD_RESUME = true;
        }
    }
}

void listenerLoopExecute()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        customurl::PROCESS_SHOULD_TERMINATE = false;
    }

    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex4);
        
        customurl::PROCESS_SHOULD_RESUME = true;
    }

}

void listenerLoopExecuteMethod()
{
    CUTF16String URL;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        std::vector<CUTF16String>::iterator it;
        
        it = customurl::CUSTOM_URL.begin();

        URL = *it;
        
        customurl::CUSTOM_URL.erase(it);
    }
    
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)customurl::LISTENER_METHOD.c_str());
    
    if(methodId)
    {
        PA_Variable    params[1];
        params[0] = PA_CreateVariable(eVK_Unistring);
        
        PA_Unistring arg1 = PA_CreateUnistring((PA_Unichar *)URL.c_str());
        PA_SetStringVariable(&params[0], &arg1);
                
        PA_ExecuteMethodByID(methodId, params, 1);
        
        PA_ClearVariable(&params[0]);

    }else if(customurl::LISTENER_METHOD.length() != 0)
    {
        PA_Variable    params[2];
        params[0] = PA_CreateVariable(eVK_Unistring);
        params[1] = PA_CreateVariable(eVK_Unistring);
        
        PA_Unistring method = PA_CreateUnistring((PA_Unichar *)customurl::LISTENER_METHOD.c_str());
        PA_SetStringVariable(&params[0], &method);
                
        PA_Unistring arg1 = PA_CreateUnistring((PA_Unichar *)URL.c_str());
        PA_SetStringVariable(&params[1], &arg1);

        PA_ExecuteCommandByID(1007 /* execute method */, params, 2);
        
        PA_ClearVariable(&params[0]);
        PA_ClearVariable(&params[1]);
    }
}

#pragma mark -

#if VERSIONMAC
static void Callback(CFNotificationCenterRef center,
                     void *observer,
                     CFStringRef name,
                     const void *object,
                     CFDictionaryRef userInfo)
{
    NSDictionary *_userInfo = (NSDictionary *)userInfo;
    NSString *url = [_userInfo valueForKey:@"url"];
    if(url) {
        
        CUTF16String URL;
        uint32_t len = [url length];
        uint32_t size = (len * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
        std::vector<uint8_t> buf(size);
        
        if([url getCString:(char *)&buf[0] maxLength:size encoding:NSUnicodeStringEncoding]){
            URL = CUTF16String((const PA_Unichar *)&buf[0], len);
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex);
                
                customurl::CUSTOM_URL.push_back(URL);
            }
            
            listenerLoopExecute();
        }
    }
}
#endif

#define USE_CLIPBOARD_FOR_SHARING_DATA 0

#if VERSIONWIN
LRESULT CALLBACK Callback(
	HWND hwnd,
	UINT uMsg,
	WPARAM wparam,
	LPARAM lparam)
{

	if (uMsg == customurl::messageIdentifier) {
		
#if USE_CLIPBOARD_FOR_SHARING_DATA
		if (OpenClipboard(NULL)) {

			UINT fmt = RegisterClipboardFormat(L"com.4D.Protocol");

			if (fmt) {

				HGLOBAL hglbCopy = GetClipboardData(fmt);

				if (hglbCopy) {
					wchar_t *lptstrCopy = (wchar_t *)GlobalLock(hglbCopy);
					if (lptstrCopy) {

						CUTF16String URL = (PA_Unichar *)lptstrCopy;
                        
                        if(1)
                        {
                            std::lock_guard<std::mutex> lock(globalMutex);
                        
                            customurl::CUSTOM_URL.push_back(URL);
                        }
						
						listenerLoopExecute();
					}
					GlobalUnlock(hglbCopy);
				}
			}
			CloseClipboard();
	}
#endif

		HANDLE fmIn = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, L"com.4D.Protocol");

		if (fmIn) {

			LPVOID bufIn = MapViewOfFile(fmIn, FILE_MAP_ALL_ACCESS, 0, 0, wparam);

			if (bufIn)
			{
				unsigned char *p = (unsigned char *)bufIn;
				try
				{
					std::vector<unsigned char>buf(wparam);
					CopyMemory(&buf[0], p, wparam);
					CUTF16String URL = (PA_Unichar *)&buf[0];
					customurl::CUSTOM_URL.push_back(URL);
					listenerLoopExecute();
				}
				catch (...)
				{

				}

				UnmapViewOfFile(bufIn);
			}

			CloseHandle(fmIn);
		}
		
		return 0;
	}

	return DefWindowProc(hwnd, uMsg, wparam, lparam);
}
#endif
